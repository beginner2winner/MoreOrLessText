package com.beginner2winner.moreorlesstext;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Color;
import android.support.annotation.Nullable;
import android.support.v7.widget.AppCompatTextView;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.TextPaint;
import android.text.style.ClickableSpan;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewTreeObserver;
import android.widget.TextView;

/**
 * MoreOrLessText is a TextView that provides a user-expand and user-contract text view.
 * This widget was written in the absence of a solution that preserved spans generated by
 * Html.fromHtml().
 *
 * In contracted view, the text view is limited to a certain number of characters and an ellipsis
 * string and a "more" string is added and the rest of the text truncated.
 * The "more" string is clickable and moves to the expanded view.
 *
 * In expanded view, the text view is not limited and a "less" string is appended to the end.
 * The "less" string is clickable and moves to the contracted view.
 *
 * A weakness of this system is that it still assumes the number of characters to remove to fit the
 * ellipsis and the "more" button, however with a proportional font it is possible that the
 * truncation is not sufficient and the "more" falls to the next line.
 *
 * Created by Richard Green, Â© Copyright Beginner2Winner Ltd
 */

public class MoreOrLessText extends AppCompatTextView {

    // Internal
    private CharSequence originalText;
    private SpannableStringBuilder substitutionText;
    private boolean stateViewMore;
    private boolean stateViewMoreLast;

    // External
    private int maxLine;
    private String ellipsisText;
    private String moreText;
    private int moreTextColour;
    private String lessText;
    private int lessTextColour;

    public MoreOrLessText(Context context) {
        this(context, null);
    }

    public MoreOrLessText(Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, R.attr.moreOrLessTextStyle);
    }

    public MoreOrLessText(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);

        if (attrs != null) {

            TypedArray typedArray = getContext().obtainStyledAttributes(
                    attrs,
                    R.styleable.MoreOrLessText,
                    defStyleAttr,
                    R.style.defaultMoreOrLessTextStyle
            );

            for (int i = 0, n = typedArray.getIndexCount(); i < n; i++) {
                int index = typedArray.getIndex(i);

                if (index == R.styleable.MoreOrLessText_moreText) {

                    this.moreText = typedArray.getString(index);

                } else if (index == R.styleable.MoreOrLessText_moreTextColour) {

                    this.moreTextColour = typedArray.getColor(index, Color.BLACK);

                } else if (index == R.styleable.MoreOrLessText_lessText) {

                    this.lessText = typedArray.getString(index);

                } else if (index == R.styleable.MoreOrLessText_lessTextColour) {

                    this.lessTextColour = typedArray.getColor(index, Color.BLACK);

                } else if (index == R.styleable.MoreOrLessText_ellipsisText) {

                    this.ellipsisText = typedArray.getString(index);

                } else if (index == R.styleable.MoreOrLessText_lessLines) {

                    this.maxLine = typedArray.getInt(index, 0);

                } else if (index == R.styleable.MoreOrLessText_startMore) {

                    this.stateViewMore = !typedArray.getBoolean(index, false);
                    this.stateViewMoreLast = !this.stateViewMore;
                }
            }
            typedArray.recycle();
        }

        observeForResizing();
    }

    private void observeForResizing() {

        ViewTreeObserver vto = getViewTreeObserver();
        vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

            @SuppressWarnings("deprecation")
            @Override
            public void onGlobalLayout() {

                ViewTreeObserver obs = getViewTreeObserver();
                obs.removeGlobalOnLayoutListener(this);

                changeText();
            }
        });
    }

    private void dontShow() {
        if (this.originalText != null) {
            setText(this.originalText, TextView.BufferType.SPANNABLE);
        }
    }

    private void changeText() {
        if (this.maxLine < 1 || this.maxLine > getLineCount()
                || this.moreText == null || this.moreText.isEmpty()
                || this.lessText == null || this.lessText.isEmpty()) {
            dontShow();
            return;
        }

        boolean textChanged = (
                this.substitutionText == null
                        || (   !getText().toString().equals(this.originalText.toString())
                        && !getText().toString().equals(this.substitutionText.toString()) )
        );

        // Ensure we have the latest original text as provided by setText() and not by this code
        if (this.originalText == null || textChanged) {
            this.originalText = getText();
        }

        if (textChanged || this.stateViewMoreLast != this.stateViewMore) {

            this.stateViewMoreLast = stateViewMore;

            // We have to avoid an index out of bounds
            int startLineIndex =
                    !this.stateViewMoreLast
                            ? getLayout().getLineStart(getLineCount() - 1)
                            : getLayout().getLineStart(this.maxLine - 1);
            int endLineIndex =
                    !this.stateViewMoreLast
                            ? length()
                            : (this.maxLine < getLineCount())
                            ? getLayout().getLineStart(this.maxLine) -1
                            : length();

            int offSetKnown = this.stateViewMore
                    ? this.ellipsisText.length() + 1 + this.moreText.length()
                    : 0; // In less we don't remove letters to make our text fit on the last line

            int offSetToUse = (endLineIndex - offSetKnown) < startLineIndex
                    ? startLineIndex
                    : offSetKnown;

            // Preserves spans (if getText is Spanned) and ensures we are working with Spans now
            this.substitutionText = new SpannableStringBuilder(
                    this.originalText,
                    0,
                    endLineIndex - offSetToUse
            );

            // Add our bits of text - no ellipsis on less
            if (this.stateViewMore) {
                this.substitutionText.append(this.ellipsisText);
            }
            this.substitutionText.append(" ");

            int preLinkLength = this.substitutionText.length();
            this.substitutionText.append(this.stateViewMore ? this.moreText : this.lessText);
            int postLinkLength = this.substitutionText.length();

            // Add Span for link on new text
            this.substitutionText.setSpan(
                    new MoreOrLessSpan(
                            false,
                            this.stateViewMore ? this.moreTextColour : this.lessTextColour
                    ),
                    preLinkLength,
                    postLinkLength,
                    0
            );

            // Done
            setText(this.substitutionText, TextView.BufferType.SPANNABLE);

            // Use instead of "setMovementMethod(LinkMovementMethod.getInstance())"
            setOnTouchListener(new TouchTextView(this.substitutionText));
        }
    }

    public void invalidateForMore() {

        observeForResizing();

        MoreOrLessText.this.setLayoutParams(MoreOrLessText.this.getLayoutParams());

        CharSequence text =
                (MoreOrLessText.this.originalText != null)
                        ? MoreOrLessText.this.originalText
                        : getText();

        setText(text, TextView.BufferType.SPANNABLE);

        MoreOrLessText.this.invalidate();
    }

    private class MoreOrLessSpan extends ClickableSpan {
        private boolean isUnderline;
        private int colour;

        private MoreOrLessSpan(boolean isUnderline, int colour) {
            this.isUnderline = isUnderline;
            this.colour = colour;
        }

        @Override
        public void updateDrawState(TextPaint ds) {
            ds.setUnderlineText(this.isUnderline);
            if (this.colour != 0) {
                ds.setColor(this.colour);
            }
        }

        @Override
        public void onClick(View widget) {

            MoreOrLessText.this.stateViewMore = !MoreOrLessText.this.stateViewMore;

            invalidateForMore();
        }
    }
}